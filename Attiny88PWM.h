/*
____________________________________________________________________________________________________________________________
|Разрядность, бит    |4      |5      |6      |7      |8     |9       |10      |11     |12     |13     |14    |15    |16    |
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Макс. значение duty |15     |31     |63     |127    |255   |511     |1023    |2047   |4095   |8191   |16383 |32767 |65535 |
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Fast PWM            |1 МГц  |516 кГц|254 кГц|126 кГц|63 кГц|31.2 кГц|15.6 кГц|7.8 кГц|3.9 кГц|1.9 кГц|980 Гц|488 Гц|244 Гц|
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Correct PWM         |571 кГц|266 кГц|129 кГц|63 кГц |32 кГц|15.7 кГц|7.8 кГц |3.9 кГц|1.9 кГц|976 Гц |488 Гц|244 Гц|122 Гц|
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|


Библиотека для расширеной генерации ШИМ на Attiny88 используя Timer1


Как расчитать частоту/разрядность/настройки в зависимсоти от нужной частоты:

    Диапазон заполнения ШИМ (duty) = 2 в степени разрядность ШИМ
    Если разрядность 10 бит то максимальное значение duty будет 2^10-1=1023 

    Fast PWM:
        Частота ШИМ = частота процессора / предделитель / (2 в степени разрядность ШИМ)
        Частота ШИМ = 16000000 / 8 / (2 ^ 13) = 244.14 Гц








Использование: 

- Задать режим генерации шим:
    mode: 0 (FAST_PWM) или 1 (CORRECT_PWM), по умолчанию 0 (FAST_PWM)
    setMode_Attiny88PWM(byte mode);

- Задать предделитель частоты таймера (если нужна очень маленькая частота ШИМ)
    prescaling: 1, 8, 64, 256 или 1024, по умолчанию 1
    setPrescaling_Attiny88PWM(int prescaling);

- Задать частоту или разрядность ШИМ, по умолчанию задана разрядность 8 бит (частота будет зависеть от режима/предделителя/частоты процессора)
    Если нужна конкретная разрядность или частота важна лишь примерно то задаем разрядность ШИМ
    resolution: от 4 до 16
    setResolution_Attiny88PWM(byte resolution);

    Или если нужна конкретная частота то задаем частоту ШИМ 
    frequency: доступный диапазон частот смотрим по таблице в зависимости от режима/предделителя/частоты процессора
    setFrequency_Attiny88PWM(uint32_t frequency);
    разрядность ШИМ будет 

- Задать скважность ШИМ на конкретном выводе, по умолчанию 0 на обоих выходах
    В процентах
    pin: ШИМ может быть на 9 и/или 10 выводе 
    duty: заполнение в процентах от 0 до 10, например 0, 27.0, 85.117 или 100 
    но точность ограниченна выбраным разрешением или максимальным разрешением для выбраной частоты
    setDutypPcent_Attiny88PWM(byte pin, float duty)

    Абсолютным значением 
    pin: ШИМ может быть на 9 и/или 10 выводе 
    duty: заполнение ШИМ
    Если задавали конкретное разрешение то диапазон заполнения равен 2 в степени разрешения, например шим 10 бит и duty будет от 0 до 2^10-1=1023
    Если задавали конкретную частоту то разрядность и соответствуюший диапазон для duty смотрим в таблице 
    setDuty_Attiny88PWM(byte pin, uint16_t duty)
    

*/

// инициализация таймера для генерации шим
void init_Attiny88PWM(byte resolution)
{
    // отключаем ШИМ пины
    DDRB &= ~(1 << PB1);
    DDRB &= ~(1 << PB2);

    // сбрасываем настройки таймера
    TCCR1B = 0;
    TCCR1A = 0;

    //
    TCCR1A |= (1 << COM1A1) | (1 << COM1B1);

    // выбираем делитель частоты 1:1
    TCCR1B |= (1 << CS10);

    // устанавливаем 14й режим работы таймера (по даташиту, Fast PWM, сброс по ICR1)
    TCCR1A |= (1 << WGM11);
    TCCR1B |= (1 << WGM12) | (1 << WGM13);

    // установка верхнего предела счетчика таймера исходя из выбраного разрешения ШИМ
    ICR1 = (1 << resolution) - 1;
}

void setDuty_Attiny88PWM(byte pin, uint16_t duty)
{
    switch (pin)
    {
    case 9:
        // отключаем пин если скважность(заполнение) = 0
        if (duty == 0)
        {
            DDRB &= ~(1 << PB1);
        }
        else
        {
            // включаем пин
            DDRB |= (1 << PB1);

            // задаем скважность(заполнение)
            OCR1A = duty;
        }
        break;

    case 10:
        if (duty == 0)
        {
            DDRB &= ~(1 << PB2);
        }
        else
        {
            DDRB |= (1 << PB2);

            OCR1B = duty;
        }
        break;

    default:
        break;
    }
}
