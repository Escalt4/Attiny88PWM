#pragma once

/*
____________________________________________________________________________________________________________________________
|Разрядность, бит    |4      |5      |6      |7      |8     |9       |10      |11     |12     |13     |14    |15    |16    |
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Макс. значение duty |15     |31     |63     |127    |255   |511     |1023    |2047   |4095   |8191   |16383 |32767 |65535 |
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Fast PWM            |1 МГц  |516 кГц|254 кГц|126 кГц|63 кГц|31.2 кГц|15.6 кГц|7.8 кГц|3.9 кГц|1.9 кГц|980 Гц|488 Гц|244 Гц|
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|
|Correct PWM         |571 кГц|266 кГц|129 кГц|63 кГц |32 кГц|15.7 кГц|7.8 кГц |3.9 кГц|1.9 кГц|976 Гц |488 Гц|244 Гц|122 Гц|
|____________________|_______|_______|_______|_______|______|________|________|_______|_______|_______|______|______|______|

*/

class Attiny88PWM
{ // класс Color
public:
    Attiny88PWM(bool correct = 0);
    void setResolution(byte color);
    void setFrequency(byte bright);
    void setDuty();

private:
    bool _correct; // Correct PWM или Fast PWM
    byte _resolution;
    uint32_t _frequency;
    uint16_t _duty;
};

Attiny88PWM::Attiny88PWM(bool correct = 0)
{
    _correct = correct;

    // отключаем ШИМ пины
    DDRB &= ~(1 << PB1);
    DDRB &= ~(1 << PB2);

    // сбрасываем настройки таймера
    TCCR1B = 0;
    TCCR1A = 0;

    //
    TCCR1A |= (1 << COM1A1) | (1 << COM1B1);

    // выбираем делитель частоты 1:1
    TCCR1B |= (1 << CS10);

    // установка нижнего предела счетчика таймера
    TCNT1 = 0;

    // установка верхнего предела счетчика таймера
    ICR1 = 65535;

    if (correct)
    {
        // устанавливаем 10й режим работы таймера (по даташиту, PWM Phase Correct, сброс по ICR1)
        TCCR1A |= (1 << WGM11);
        TCCR1B |= (1 << WGM13);
    }
    else
    {
        // устанавливаем 14й режим работы таймера (по даташиту, Fast PWM, сброс по ICR1)
        TCCR1A |= (1 << WGM11);
        TCCR1B |= (1 << WGM12) | (1 << WGM13);
    }
}

// инициализация таймера для генерации шим
void Attiny88PWM::setResolution(byte resolution)
{
    _resolution = resolution;

    // установка верхнего предела счетчика таймера исходя из выбраного разрешения ШИМ
    ICR1 = (1 << resolution) - 1;
}

// частота должна быть выше 244 Гц
void Attiny88PWM::setFrequency(uint32_t frequency)
{
    _frequency = constrain(frequency, 245, 1000000);

    // соотносим с частотой разрядность
    for (byte i = 8; i < 16; i++)
    {
        if ((1 << i) >= 1)
        {
            _resolution = i;
            break;
        }
    }

    // установка верхнего предела счетчика таймера исходя из выбраной частоты
    ICR1 = 16000000 / frequency;
}

void setDuty(byte pin, uint16_t duty)
{
    _duty = duty;

    switch (pin)
    {
    case 9:
        // отключаем пин если скважность(заполнение) = 0
        if (duty == 0)
        {
            DDRB &= ~(1 << PB1);
        }
        else
        {
            // включаем пин
            DDRB |= (1 << PB1);

            // задаем скважность(заполнение)
            OCR1A = map(duty, 0, (1 << resolution) - 1, 0, ICR1);
        }
        break;

    case 10:
        if (duty == 0)
        {
            DDRB &= ~(1 << PB2);
        }
        else
        {
            DDRB |= (1 << PB2);

            // задаем скважность(заполнение)
            OCR1B = map(duty, 0, (1 << resolution) - 1, 0, ICR1);
        }
        break;

    default:
        break;
    }
}
